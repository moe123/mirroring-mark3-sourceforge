import struct
import serial

class buffalogger:
    def __init__(self,symfile,header):
        self.symfile = symfile
        self.headerfile = header
        self.reload()

    def reload(self):
        # Clear member data
        self.str = ""
        self.header = ""
        self.filemap = list()
        self.stringmap = list()
        self.decodearray = ""
        self.syncidx = 0

        # Load the symbols file
        obj = open(self.symfile, "r")
        self.str = obj.read()
        obj.close()

        # Load the headers file
        obj = open(self.headerfile, "r")
        self.header = obj.read()
        obj.close()

        # Parse through the header file and extract mapping of filenames to numbers
        idx = 0;

        # Remove the format strings - this is all brute-force-ish based on the format
        # of the autogenerated contents of dbg_file_list.h
        self.header = self.header.translate(None, "()")
        header_lines = self.header.split("\n")
        for header_line in header_lines[2:]:
            header_tokens = header_line.split()
            if len(header_tokens) < 2:
                continue

            # Parse out the file name and number strings
            name_token = header_tokens[1]
            name_str = name_token[7:] # truncte the "_DBG___" prefix
            name_str = name_str.lower() # Convert to lowercase
            name_str = name_str.replace("_",".") # Convert _ to . to make the filenames look nicer
            file_num = int(header_tokens[2])

            # Add the tuple (file #, filename) to the list
            self.filemap.append((file_num, name_str))

            dat = { "filename" : name_str, "file_num" : file_num }

            self.stringmap.append( (dat) )

        # Parse through the symbol file and extract debug strings with file number/name,
        # and line numbers.
        idx = 0
        start_idx = 0
        token = 0
        line_no = 0
        file_no = 0
        format_str = ""

        # Parse out the binary symbol file, which contains data in the following format:
        #   null-terminated format string
        #   2-byte file no
        #   2-byte line no
        #   2-byte synchronization cookie
        # Integers are unsigned, little-endian

        while idx < len(self.str):
            if (self.str[idx]) == b'\x00':
                format_str = self.str[start_idx:idx]
                # Count the number of arguments this string takes.  Limited to a small
                # subset of printf-like formatters
                arg_count = 0
                arg_count += format_str.count("%d");
                arg_count += format_str.count("%x");
                arg_count += format_str.count("%i");
                arg_count += format_str.count("%u");

                (line_no, file_no, token) = struct.unpack('<HHH', self.str[idx+1:idx+7])

                # Parse out indexes at which to insert the arguments in the format
                searchstrs = list()
                searchstrs.append("%d")
                searchstrs.append("%i")
                searchstrs.append("%u")
                searchstrs.append("%x")

                # Find all of the indexes and map the index to the format type
                replace_idx = list()
                for searchstr in searchstrs:
                    tmpstr = format_str
                    tmpidx = tmpstr.find(searchstr)
                    while tmpidx > -1:
                        replace_idx.append((tmpidx, searchstr))
                        findidx = tmpstr[tmpidx+2:].find(searchstr)
                        if findidx != -1:
                            tmpidx += findidx + 2
                        else:
                            tmpidx = findidx
                # Sort the substring items by index
                replace_idx.sort()

                start_idx = idx + 7
                idx += 7

                dat = { str(line_no) : (format_str, replace_idx) }
                print dat
                self.stringmap[file_no].update( (dat) )
            else:
                idx += 1

    def decode(self,data):
        # Add the data to the decoder's temporary decode buffer
        if (data != ""):
            self.decodearray += data

        # Try to find the first frame-sync
        framesync = "\xDC\xAC"
        matchidx = self.decodearray.find(framesync)

        # No match, try again later
        if matchidx == -1:
            # If the decoder array is getting too big for a valid string,
            # abandon the current buffer.
            if len(self.decodearray) > 64:
                self.decodearray = ""
            return 0

        # Found a first-packet match, prune preceding whitespace
        if (matchidx != 0):
            self.decodearray = self.decodearray[matchidx:]

        # Wait until we have a complete header
        if (len(self.decodearray) < 8):
            return 0

        # Check for the *next* framesync
        (token, fileno, lineno, syncidx) = struct.unpack('<HHHH', self.decodearray[0:8])

        # Verify that the file number is valid - if not, then we're likely still in an
        # unsynchronized state
        if (fileno > len(self.filemap)):
            self.decodearray = ""
            return 0

        # Decode the line number/string/argument count
        line_str = ""
        arg_data = list();
        if str(lineno) in self.stringmap[fileno]:
            # Read the number of arguments for the given line number
            (line_str, arg_data) = (self.stringmap[fileno])[str(lineno)]
        else:
            # The string doesn't exist, assume an error in encoding
            self.decodearray = ""
            print "Encode error: %d %d, %d" %(syncidx, fileno, lineno)
            return 0

        # Verify that we've reached the end of the packet + start of next sync.
        arg_count = len(arg_data)
        packet_len = (8 + (2 * (arg_count)))
        next_syncidx = (8 + (2 * (arg_count + 1)))
        if len(self.decodearray) < next_syncidx:
            return 0

        # Verify that the start of the next packet is where it should be
        matchidx = self.decodearray[next_syncidx:(next_syncidx + 2)]
        if -1 == matchidx:
            # Nope.  Error in decode.
            self.decodearray = ""
            print "ERROR IN DECODE"
            return 0

        # Check to see if we have continuous logs
        # if ((self.syncidx + 1) % 65536) != syncidx:
            # Log was unsynchronized - restart count, but ignore this packet
            #self.syncidx = syncidx
            #  return 0

        self.syncidx = syncidx

        # Packet decoded OK, parse out the arguments.
        args = list()
        outstr = line_str

        for idx in range(0,arg_count):
            args.append( struct.unpack('<H', self.decodearray[(8+(idx*2)):(10+(idx*2))]) )

        # Construct the output string using the read arguments and precomputed insert points
        if arg_count:
            final_str = outstr[0:arg_data[0][0]]
            final_str += str(args[0][0])
            for arg in range(1, arg_count-1):
                final_str = outstr[(replace_idx[arg-1]+2):arg_data[arg][0]]
                final_str += str(args[arg][0])
            final_str += outstr[arg_data[arg_count-1][0]+2:]
        else:
            final_str = outstr;

        print "%d: [%s:%d] %s" % (syncidx, (self.stringmap[fileno])['filename'], fileno, final_str)

        # Discard the packet we just finished
        self.decodearray = self.decodearray[next_syncidx-2:]
        return 1

# Testing...
symfile = "/home/vm/mark3/trunk/embedded/stage/dbg/avr/atmega328p/gcc/buffalogger.dbg"
headerfile = "/home/vm/mark3/trunk/embedded/kernel/public/dbg_file_list.h"

logger = buffalogger(symfile, headerfile)
print logger.stringmap

infile = open("test.txt", "r")
filedat = infile.read()

idx = 0
while idx < len(filedat):
    working = logger.decode(filedat[idx])
    idx += 1
